<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".autogenerated.cs" #>
//====================================================================================================
// <auto-generated>       THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY       </auto-generated>
//====================================================================================================

using Enderlook.Unity.Threading;

using System.Collections.Generic;

namespace Enderlook.Unity.Pathfinding.Algorithms
{
    /// <summary>
    /// A pathfinder that uses the Theta algorithm.
    /// </summary>
    internal static class ThetaStar
    {
<#
    foreach (Variation variation in new Variation[] {
        new Variation() { HasWatchdog = true , HasSearcher = true  },
        new Variation() { HasWatchdog = true , HasSearcher = false },
        new Variation() { HasWatchdog = false, HasSearcher = true  },
        new Variation() { HasWatchdog = false, HasSearcher = false },
    })
    {
        bool hasWatchdog = variation.HasWatchdog;
        bool hasSearcher = variation.HasSearcher;

        string IfHasWatchdog(string input) => hasWatchdog ? input : "";
        string IfHasSearcher(string input) => hasSearcher ? input : "";
        string IfElseHasSearcher(string input, string otherwise) => hasSearcher ? input : otherwise;
        string IfHasntSearcher(string input) => !hasSearcher ? input : "";
#>
        <#= variation.ToString() #>

        public static void CalculatePath<TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher ") #> <#= IfHasWatchdog(", TWatchdog") #>>(
             TGraph graph,
             TBuilder builder,
             TCoord from
             <#= IfHasntSearcher(", TCoord to") #>
             <#= IfHasSearcher(", TSearcher searcher") #>
             <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
             where TNodes : IEnumerator<TNode>
             where TGraph : class, IGraphIntrinsic<TNode, TNodes> <#= IfHasntSearcher(", IGraphHeuristic<TNode>") #>, IGraphLocation<TNode, TCoord>, IGraphLineOfSight<TCoord>
             where TBuilder : IPathBuilder<TNode, TCoord>
             <#= IfHasSearcher("where TSearcher :  ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
             <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
        {
            builder.InitializeBuilderSession();
            builder.SetGraphLocation(graph);
            builder.SetLineOfSight(graph);
            TNode from_ = graph.FindClosestNodeTo(from);
            builder.SetStart(from, from_);

<#      if (hasSearcher) { #>
            if (searcher.DoesSatisfy(from_))
<#      } else { #>
            TNode to_ = graph.FindClosestNodeTo(to);
            if (EqualityComparer<TNode>.Default.Equals(from_, to_))
<#      } #>
            {
                builder.SetEnd(from, from_);
                builder.FinalizeBuilderSession(CalculationResult.PathFound);
                return;
            }

            builder.SetCost(from_, 0);
            builder.EnqueueToVisit(from_, 0);

            // Context switching is insanely slow, so we need this boilerplate in order to execute a bulky check and amortize the switch cost
            // Also, we can't use stackalloc due the async nature of the switching
            DynamicArray<TNode> neighbourNodes = DynamicArray<TNode>.Create();
            DynamicArray<TNode> parents = DynamicArray<TNode>.Create();
            DynamicArray<TCoord> parentPositions = DynamicArray<TCoord>.Create();
            DynamicArray<TCoord> neighbourPositions = DynamicArray<TCoord>.Create();
            DynamicArray<bool> results = DynamicArray<bool>.Create();
            DynamicArray<bool> hasEdges = DynamicArray<bool>.Create();

            while (builder.TryDequeueToVisit(out TNode node))
            {
<#      if (hasWatchdog) { #>
                if (!watchdog.CanContinue())
                {
                    builder.SetEnd(default, default);
                    builder.FinalizeBuilderSession(CalculationResult.Timedout);
                    return;
                }
<#      } #>

                if (builder.WasVisited(node))
                    continue;
                builder.Visit(node);

                TNodes neighbours = graph.GetNeighbours(node);

                if (!ThreadSwitcher.IsExecutingMainThread)
                {
                    try
                    {
                        neighbourNodes.Clear();
                        parentPositions.Clear();
                        parents.Clear();
                        neighbourPositions.Clear();
                        hasEdges.Clear();
                        results.Clear();
                        while (neighbours.MoveNext())
                        {
                            TNode neighbour = neighbours.Current;
                            neighbourNodes.Add(neighbour);
                            neighbourPositions.Add(graph.ToPosition(neighbour));
                            bool has = builder.TryGetEdge(neighbour, out TNode parent);
                            hasEdges.Add(has);
                            if (has)
                                parentPositions.Add(graph.ToPosition(parent));
                            else
                                parentPositions.Add(default);
                            parents.Add(parent);
                            results.Add(false);
                        }
                    }
                    finally
                    {
                        neighbours.Dispose();
                    }

                    graph.HasLineOfSightBulk(parentPositions.UnderlyingArray, neighbourPositions.UnderlyingArray, results.UnderlyingArray, neighbourPositions.Count);

                    for (int i = 0; i < neighbourNodes.Count; i++)
                    {
                        TNode neighbour = neighbourNodes[i];

                        TNode currentParent;
                        if (hasEdges[i] && results[i])
                            currentParent = parents[i];
                        else
                            currentParent = node;

                        if (!builder.TryGetCost(currentParent, out float costFromSource))
                            costFromSource = float.PositiveInfinity;

                        float cost = graph.GetCost(currentParent, neighbour) + costFromSource;
                        if (!builder.TryGetCost(neighbour, out float oldCost) || cost < oldCost)
                        {
                            builder.SetCost(neighbour, cost);
                            builder.SetEdge(currentParent, neighbour);
                        }

                        float costWithHeuristic = cost + <#= IfElseHasSearcher("searcher.GetHeuristicCost(neighbour)", "graph.GetHeuristicCost(neighbour, to_)") #>;
                        builder.EnqueueToVisit(neighbour, costWithHeuristic);

<#      if (hasSearcher) { #>
                            if (searcher.DoesSatisfy(neighbour))
<#      } else { #>
                            if (EqualityComparer<TNode>.Default.Equals(to_, neighbour))
<#      } #>
                        {
                            builder.SetEnd(<#= IfElseHasSearcher("graph.ToPosition(neighbour)", "to") #>, neighbour);
                            builder.FinalizeBuilderSession(CalculationResult.PathFound);
                            return;
                        }
                    }
                }
                else
                {
                    try
                    {
                        TNode neighbour;
                        while (neighbours.MoveNext())
                        {
                            neighbour = neighbours.Current;

                            TNode currentParent;
                            if (builder.TryGetEdge(neighbour, out TNode parent) && graph.HasLineOfSight(graph.ToPosition(parent), graph.ToPosition(neighbour)))
                                currentParent = parent;
                            else
                                currentParent = node;

                            if (!builder.TryGetCost(currentParent, out float costFromSource))
                                costFromSource = float.PositiveInfinity;

                            float cost = graph.GetCost(currentParent, neighbour) + costFromSource;
                            if (!builder.TryGetCost(neighbour, out float oldCost) || cost < oldCost)
                            {
                                builder.SetCost(neighbour, cost);
                                builder.SetEdge(currentParent, neighbour);
                            }

                            float costWithHeuristic = cost + <#= IfElseHasSearcher("searcher.GetHeuristicCost(neighbour)", "graph.GetHeuristicCost(neighbour, to_)") #>;
                            builder.EnqueueToVisit(neighbour, costWithHeuristic);

<#      if (hasSearcher) { #>
                            if (searcher.DoesSatisfy(neighbour))
<#      } else { #>
                            if (EqualityComparer<TNode>.Default.Equals(to_, neighbour))
<#      } #>
                            {
                                builder.SetEnd(<#= IfElseHasSearcher("graph.ToPosition(neighbour)", "to") #>, neighbour);
                                builder.FinalizeBuilderSession(CalculationResult.PathFound);
                                return;
                            }
                        }
                    }
                    finally
                    {
                        neighbours.Dispose();
                    }
                }
            }

            builder.SetEnd(default, default);
            builder.FinalizeBuilderSession(CalculationResult.PathNotFound);
        }

<#  } #>
    }
}
<#+
struct Variation
{
    public bool HasWatchdog;
    public bool HasSearcher;

    public string ToString() => String.Format("// HasWatchdog: {0} HasSearcher: {1}", HasWatchdog, HasSearcher);
}
#>
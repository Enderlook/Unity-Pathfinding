<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".autogenerated.cs" #>
//====================================================================================================
// <auto-generated>       THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY       </auto-generated>
//====================================================================================================

using System.Collections.Generic;
using System.Runtime.InteropServices;

using Unity.Jobs;

namespace Enderlook.Unity.Pathfinding.Algorithms
{
     internal sealed partial class Manager<TCoord, TNode, TNodes, TGraph, TBuilder>
    {
<#
    foreach (Variation variation in new Variation[] {
        new Variation() { HasWatchdog = true , HasSearcher = true  },
        new Variation() { HasWatchdog = true , HasSearcher = false },
        new Variation() { HasWatchdog = false, HasSearcher = true  },
        new Variation() { HasWatchdog = false, HasSearcher = false },
    })
    {
        bool hasWatchdog = variation.HasWatchdog;
        bool hasSearcher = variation.HasSearcher;

        string IfHasWatchdog(string input) => hasWatchdog ? input : "";
        string IfHasSearcher(string input) => hasSearcher ? input : "";
        string IfElseHasSearcher(string input, string otherwise) => hasSearcher ? input : otherwise;
        string IfHasntSearcher(string input) => !hasSearcher ? input : "";
#>
        <#= variation.ToString() #>

        public void CalculatePathSync<<#= IfHasSearcher("TSearcher, ") #> TPath <#= IfHasWatchdog(", TWatchdog") #>>(
             TPath path,
             TCoord from
             <#= IfElseHasSearcher(", TSearcher searcher", ", TCoord to") #>
             <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
             where TPath : class, IPathFeedable<TCoord>, IEnumerable<TCoord>
             <#= IfHasSearcher("where TSearcher : ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
             <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
        {
            ((IProcessHandleProducer)path).StartFromSync();

            AStar.CalculatePath<TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                (graph, builderSync, from, <#= IfElseHasSearcher("searcher", "to") #> <#= IfHasWatchdog(", watchdog") #>);

            builderSync.FeedPathTo(path);

            ((IProcessHandleProducer)path).EndFromSync();
        }

        public void CalculatePath<<#= IfHasSearcher("TSearcher, ") #> TPath <#= IfHasWatchdog(", TWatchdog") #>>(
             TPath path,
             TCoord from,
             <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
             <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
             where TPath : class, IPathFeedable<TCoord>, IEnumerable<TCoord>
             <#= IfHasSearcher("where TSearcher : class, ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
             <#= IfHasWatchdog("where TWatchdog : unmanaged, IWatchdog") #>
        {
            var job = Job<#= variation.Code() #><TPath <#= IfHasSearcher(", TSearcher") #>  <#= IfHasWatchdog(", TWatchdog") #>>.Create(
                this, path, from, <#= IfElseHasSearcher("searcher", "to") #> <#= IfHasWatchdog(", watchdog") #>
            );
            JobHandle jobHandle = job.Schedule();
            ((IProcessHandleProducer)path).StartFromJobHandle(jobHandle);
        }

        private readonly struct Job<#= variation.Code() #>
            <TPath <#= IfHasSearcher(", TSearcher") #>  <#= IfHasWatchdog(", TWatchdog") #>>
            : IJob
            where TPath : class, IPathFeedable<TCoord>, IEnumerable<TCoord>
            <#= IfHasSearcher("where TSearcher : class, ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
            <#= IfHasWatchdog("where TWatchdog : unmanaged, IWatchdog") #>
        {
            private readonly GCHandle managerHandle;
            private readonly GCHandle pathHandle;
            <#= IfHasSearcher("private readonly GCHandle searcherHandle;") #>
            <#= IfHasWatchdog("private readonly TWatchdog watchdog;") #>
            private readonly TCoord from;
            <#= IfHasntSearcher("private readonly TCoord to;") #>

            private Job<#= variation.Code() #>(
                Manager<TCoord, TNode, TNodes, TGraph, TBuilder> manager,
                GCHandle pathHandle,
                TCoord from,
                <#= IfElseHasSearcher("GCHandle searcherHandle", "TCoord to") #>
                <#= IfHasWatchdog(", TWatchdog watchdog") #>
            )
            {
                this.managerHandle = GCHandle.Alloc(manager, GCHandleType.Pinned);
                this.pathHandle = pathHandle;
                this.from = from;
                <#= IfElseHasSearcher("this.searcherHandle = searcherHandle;", "this.to = to;") #>
                <#= IfHasWatchdog("this.watchdog = watchdog;") #>
            }

            public static Job<#= variation.Code() #><TPath <#= IfHasSearcher(", TSearcher") #>  <#= IfHasWatchdog(", TWatchdog") #>> Create(
                Manager<TCoord, TNode, TNodes, TGraph, TBuilder> manager,
                TPath path,
                TCoord from,
                <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
                <#= IfHasWatchdog(", TWatchdog watchdog") #>
            )
            {
                return new Job<#= variation.Code() #><TPath <#= IfHasSearcher(", TSearcher") #>  <#= IfHasWatchdog(", TWatchdog") #>>(
                    manager,
                    GCHandle.Alloc(path, GCHandleType.Pinned),
                    from,
                    <#= IfElseHasSearcher("GCHandle.Alloc(searcher, GCHandleType.Pinned)", "to") #>
                    <#= IfHasWatchdog(", watchdog") #>
                );
            }

            public void Execute()
            {
                Manager<TCoord, TNode, TNodes, TGraph, TBuilder> manager = (Manager<TCoord, TNode, TNodes, TGraph, TBuilder>)managerHandle.Target;

                TBuilder builder = manager.GetBuilder();
                TPath path = (TPath)pathHandle.Target;
                <#= IfHasSearcher("TSearcher searcher = (TSearcher)searcherHandle.Target;") #>

                AStar.CalculatePath<TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                    (manager.graph, builder, from, <#= IfElseHasSearcher("searcher", "to") #> <#= IfHasWatchdog(", watchdog") #>);

                ((IPathFeeder<TCoord>)builder).FeedPathTo(path);

                manager.StoreBuilder(builder);
                managerHandle.Free();
                <#= IfHasSearcher("searcherHandle.Free();") #>
                ((IProcessHandleProducer)path).EndFromJobHandle();
                pathHandle.Free();
            }
        }

<#  } #>
    }
}
<#+
struct Variation
{
    public bool HasWatchdog;
    public bool HasSearcher;

    public string ToString() => String.Format("// HasWatchdog: {0} HasSearcher: {1}", HasWatchdog, HasSearcher);

    public string Code() => (HasWatchdog ? "YW" : "NW") + (HasSearcher ? "YS" : "NS");
}
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".autogenerated.cs" #>
//====================================================================================================
// <auto-generated>       THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY       </auto-generated>
//====================================================================================================

using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using UnityEngine;
using Unity.Jobs;

namespace Enderlook.Unity.Pathfinding.Algorithms
{
    internal static partial class PathCalculator
    {
<#
    foreach (Variation variation in new Variation[] {
        new Variation() { HasWatchdog = true , HasSearcher = true  },
        new Variation() { HasWatchdog = true , HasSearcher = false },
        new Variation() { HasWatchdog = false, HasSearcher = true  },
        new Variation() { HasWatchdog = false, HasSearcher = false },
    })
    {
        bool hasWatchdog = variation.HasWatchdog;
        bool hasSearcher = variation.HasSearcher;
        bool hasWatchdogOrSearcher = hasWatchdog || hasSearcher;

        string IfHasWatchdog(string input) => hasWatchdog ? input : "";
        string IfHasSearcher(string input) => hasSearcher ? input : "";
        string IfElseHasSearcher(string input, string otherwise) => hasSearcher ? input : otherwise;
        string IfHasntSearcher(string input) => !hasSearcher ? input : "";
        string IfHasWatchdogOrSearcher(string input) => hasWatchdogOrSearcher ? input : "";

        string genericDeclaration = "<TCoord, TNode, TNodes, TGraph, TBuilder, TPath " + IfHasSearcher(", TSearcher") + IfHasWatchdog(", TWatchdog") + ">";
        string genericConstrains =
            "where TNodes : IEnumerator<TNode>" +
            "\r\n            where TGraph : class, IGraphIntrinsic<TNode, TNodes>, IGraphHeuristic<TNode>, IGraphLocation<TNode, TCoord>, IGraphLineOfSight<TCoord>" +
            "\r\n            where TBuilder : class, IPathBuilder<TNode, TCoord>, IPathFeeder<TCoord>, new()" +
            "\r\n            where TPath : class, IPathFeedable<TCoord>, IEnumerable<TCoord>" +
            IfHasSearcher("\r\n            where TSearcher : ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") +
            IfHasWatchdog("\r\n            where TWatchdog : IWatchdog");
#>
        <#= variation.ToString() #>

        public static void CalculatePathSingleThread<#= genericDeclaration #>
        (
            TGraph graph,
            TPath path,
            TCoord from
            <#= IfElseHasSearcher(", TSearcher searcher", ", TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= genericConstrains #>
        {
            ((IProcessHandleSourceCompletition)path).Start();

            var builder = ConcurrentPool<TBuilder>.Rent();

            ThetaStar.CalculatePath
                <TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                (graph, builder, from, <#= IfElseHasSearcher("searcher", "to") #> <#= IfHasWatchdog(", watchdog") #>);

            builder.FeedPathTo(path);

            ConcurrentPool<TBuilder>.Return(builder);

            ((IProcessHandleSourceCompletition)path).End();
        }

        private struct Handle<#= variation.Code() #><#= genericDeclaration #>
            <#= genericConstrains #>
        {
            internal TGraph graph;
            internal TPath path;
            internal TBuilder builder;
            <#= IfHasSearcher("internal TSearcher searcher;") #>
            <#= IfHasWatchdog("internal TWatchdog watchdog;") #>
            internal TCoord from;
            <#= IfHasntSearcher("internal TCoord to;") #>

            public void Set(
                TGraph graph,
                TBuilder builder,
                TPath path,
                TCoord from,
                <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
                <#= IfHasWatchdog(", TWatchdog watchdog") #>
            )
            {
                this.graph = graph;
                this.builder = builder;
                this.path = path;
                this.from = from;
                <#= IfElseHasSearcher("this.searcher = searcher;", "this.to = to;") #>
                <#= IfHasWatchdog("this.watchdog = watchdog;") #>
            }

            public static void Execute(GCHandle handleHandle)
            {
                var boxedHandle = ((StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>>)handleHandle.Target);

                Execute(boxedHandle);

                handleHandle.Free();
            }

            public static void Execute(StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>> boxedHandle)
            {
                var handle = boxedHandle.Value;

                handle.Execute();

                ConcurrentPool<StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>>>.Return(boxedHandle);
            }

            public void Execute()
            {
                ThetaStar.CalculatePath<TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                    (graph, builder, from, <#= IfElseHasSearcher("searcher", "to") #> <#= IfHasWatchdog(", watchdog") #>);

                ((IPathFeeder<TCoord>)builder).FeedPathTo(path);

                ((IProcessHandleSourceCompletition)path).End();

                ConcurrentPool<TBuilder>.Return(builder);
            }
        }

        public static void CalculatePathJob<#= genericDeclaration #>
        (
            TGraph graph,
            TPath path,
            TCoord from,
            <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= genericConstrains #>
        {
            if (Application.platform == RuntimePlatform.WebGLPlayer)
                CalculatePathJobNoAlloc<#= genericDeclaration #>(graph, path, from <#= IfElseHasSearcher(", searcher", ", to") #> <#= IfHasWatchdog(", watchdog") #>);
            else
                CalculatePathJobAlloc<#= genericDeclaration #>(graph, path, from <#= IfElseHasSearcher(", searcher", ", to") #> <#= IfHasWatchdog(", watchdog") #>);
        }

        private static void CalculatePathJobAlloc<#= genericDeclaration #>
        (
            TGraph graph,
            TPath path,
            TCoord from,
            <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= genericConstrains #>
        {
            ((IProcessHandleSourceCompletition)path).Start();

            var boxedHandle = ConcurrentPool<StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>>>.Rent();
            boxedHandle.Value.Set(graph, ConcurrentPool<TBuilder>.Rent(), path, from <#= IfElseHasSearcher(", searcher", ", to") #> <#= IfHasWatchdog(", watchdog") #>);

            var job = new Job<#= variation.Code() #>Handle<#= genericDeclaration #>(boxedHandle);
            JobHandle jobHandle = job.Schedule();

            ((IProcessHandleSourceCompletition)path).SetJobHandle(jobHandle);
        }

        private readonly struct Job<#= variation.Code() #>Handle<#= genericDeclaration #> : IJob
            <#= genericConstrains #>
        {
            private readonly GCHandle handle;

            public Job<#= variation.Code() #>Handle(
                StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>> handle
            )
                => this.handle = GCHandle.Alloc(handle, GCHandleType.Pinned);

            public void Execute()
                => Handle<#= variation.Code() #><#= genericDeclaration #>.Execute(handle);
        }

        private static void CalculatePathJobNoAlloc<#= genericDeclaration #>
        (
            TGraph graph,
            TPath path,
            TCoord from,
            <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= genericConstrains #>
        {
            ((IProcessHandleSourceCompletition)path).Start();

            var handle = new Handle<#= variation.Code() #><#= genericDeclaration #>();
            handle.Set(graph, ConcurrentPool<TBuilder>.Rent(), path, from <#= IfElseHasSearcher(", searcher", ", to") #> <#= IfHasWatchdog(", watchdog") #>);

            long key = GlobalDictionary<Handle<#= variation.Code() #><#= genericDeclaration #>>.Store(handle);

            var job = new Job<#= variation.Code() #>Key<#= genericDeclaration #>(key);
            JobHandle jobHandle = job.Schedule();

            ((IProcessHandleSourceCompletition)path).SetJobHandle(jobHandle);
        }

        private readonly struct Job<#= variation.Code() #>Key<#= genericDeclaration #> : IJob
            <#= genericConstrains #>
        {
            private readonly long key;

            public Job<#= variation.Code() #>Key(
                long key
            )
                => this.key = key;

            public void Execute()
            {
                var handle = GlobalDictionary<Handle<#= variation.Code() #><#= genericDeclaration #>>.Drain(key);
                handle.Execute();
            }
        }

<#  } #>
    }
}
<#+
struct Variation
{
    public bool HasWatchdog;
    public bool HasSearcher;

    public string ToString() => String.Format("// HasWatchdog: {0} HasSearcher: {1}", HasWatchdog, HasSearcher);

    public string Code() => (HasWatchdog ? "YW" : "NW") + (HasSearcher ? "YS" : "NS");
}
#>
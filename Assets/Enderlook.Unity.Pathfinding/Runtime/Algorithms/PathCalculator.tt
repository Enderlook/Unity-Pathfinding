<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".autogenerated.cs" #>
//====================================================================================================
// <auto-generated>       THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY       </auto-generated>
//====================================================================================================

using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using Unity.Jobs;

namespace Enderlook.Unity.Pathfinding.Algorithms
{
    internal static partial class PathCalculator<TCoord, TNode, TNodes, TGraph, TBuilder, TPath>
        where TCoord : unmanaged
        where TNode : unmanaged
        where TNodes : IEnumerator<TNode>
        where TGraph : class, IGraphIntrinsic<TNode, TNodes>, IGraphHeuristic<TNode>, IGraphLocation<TNode, TCoord>
        where TBuilder : class, IPathBuilder<TNode, TCoord>, IPathFeeder<TCoord>, new()
        where TPath : class, IPathFeedable<TCoord>, IEnumerable<TCoord>
    {
         private static readonly TBuilder builderSingleThread = new TBuilder();

<#
    foreach (Variation variation in new Variation[] {
        new Variation() { HasWatchdog = true , HasSearcher = true  },
        new Variation() { HasWatchdog = true , HasSearcher = false },
        new Variation() { HasWatchdog = false, HasSearcher = true  },
        new Variation() { HasWatchdog = false, HasSearcher = false },
    })
    {
        bool hasWatchdog = variation.HasWatchdog;
        bool hasSearcher = variation.HasSearcher;
        bool hasWatchdogOrSearcher = hasWatchdog || hasSearcher;

        string IfHasWatchdog(string input) => hasWatchdog ? input : "";
        string IfHasSearcher(string input) => hasSearcher ? input : "";
        string IfElseHasSearcher(string input, string otherwise) => hasSearcher ? input : otherwise;
        string IfHasntSearcher(string input) => !hasSearcher ? input : "";
        string IfHasWatchdogOrSearcher(string input) => hasWatchdogOrSearcher ? input : "";
#>
        <#= variation.ToString() #>

        public static void CalculatePathSingleThread
            <#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>
        (
            TGraph graph,
            TPath path,
            TCoord from
            <#= IfElseHasSearcher(", TSearcher searcher", ", TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= IfHasSearcher("where TSearcher : ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
            <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
        {
            lock (builderSingleThread) // Actually, we don't need the lock because we explictly state that it is not thread-safe
            {
                ((IProcessHandleSourceCompletition)path).StartFromSync();

                AStar.CalculatePath
                    <TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                    (graph, builderSingleThread, from, <#= IfElseHasSearcher("searcher", "to") #> <#= IfHasWatchdog(", watchdog") #>);

                builderSingleThread.FeedPathTo(path);

                ((IProcessHandleSourceCompletition)path).EndFromSync();
            }
        }

        private struct Handle<#= variation.Code() #>
            <#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>
            <#= IfHasSearcher("where TSearcher : ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
            <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
        {
            internal TGraph graph;
            internal TPath path;
            internal TBuilder builder;
            <#= IfHasSearcher("internal TSearcher searcher;") #>
            <#= IfHasWatchdog("internal TWatchdog watchdog;") #>
            internal TCoord from;
            <#= IfHasntSearcher("internal TCoord to;") #>

            public void Set(
                TGraph graph,
                TBuilder builder,
                TPath path,
                TCoord from,
                <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
                <#= IfHasWatchdog(", TWatchdog watchdog") #>
            )
            {
                this.graph = graph;
                this.builder = builder;
                this.path = path;
                this.from = from;
                <#= IfElseHasSearcher("this.searcher = searcher;", "this.to = to;") #>
                <#= IfHasWatchdog("this.watchdog = watchdog;") #>
            }
        }

        public static void CalculatePathJobAlloc
            <#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>
        (
            TGraph graph,
            TPath path,
            TCoord from,
            <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= IfHasSearcher("where TSearcher : ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
            <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
        {
            var boxedHandle = ConcurrentPool<StrongBox<Handle<#= variation.Code() #>
                <#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>
            >>.Rent();
            boxedHandle.Value.Set(graph, ConcurrentPool<TBuilder>.Rent(), path, from <#= IfElseHasSearcher(", searcher", ", to") #> <#= IfHasWatchdog(", watchdog") #>);

            var job = new Job<#= variation.Code() #>
                <#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>
                (boxedHandle);
            JobHandle jobHandle = job.Schedule();

            ((IProcessHandleSourceCompletition)path).StartFromJobHandle(jobHandle);
        }

        private readonly struct Job<#= variation.Code() #>
            <#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>
            : IJob
            <#= IfHasSearcher("where TSearcher : ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
            <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
        {
            private readonly GCHandle handle;

            public Job<#= variation.Code() #>(
                StrongBox<Handle<#= variation.Code() #><#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>> handle
            )
                => this.handle = GCHandle.Alloc(handle, GCHandleType.Pinned);

            public void Execute()
            {
                var boxedHandle = ((StrongBox<Handle<#= variation.Code() #><#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>>)this.handle.Target);
                var handle = boxedHandle.Value;

                AStar.CalculatePath<TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                    (handle.graph, handle.builder, handle.from, <#= IfElseHasSearcher("handle.searcher", "handle.to") #> <#= IfHasWatchdog(", handle.watchdog") #>);

                ((IPathFeeder<TCoord>)handle.builder).FeedPathTo(handle.path);

                ((IProcessHandleSourceCompletition)handle.path).EndFromJobHandle();

                ConcurrentPool<StrongBox<Handle<#= variation.Code() #>
                    <#= IfHasWatchdogOrSearcher("<" + IfHasSearcher("TSearcher" + IfHasWatchdog(", ")) + IfHasWatchdog("TWatchdog") + ">") #>>>
                    .Return(boxedHandle);

                this.handle.Free();
            }
        }

<#  } #>
    }
}
<#+
struct Variation
{
    public bool HasWatchdog;
    public bool HasSearcher;

    public string ToString() => String.Format("// HasWatchdog: {0} HasSearcher: {1}", HasWatchdog, HasSearcher);

    public string Code() => (HasWatchdog ? "YW" : "NW") + (HasSearcher ? "YS" : "NS");
}
#>
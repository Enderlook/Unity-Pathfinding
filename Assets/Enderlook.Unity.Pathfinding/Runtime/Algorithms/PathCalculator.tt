<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".autogenerated.cs" #>
//====================================================================================================
// <auto-generated>       THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY       </auto-generated>
//====================================================================================================

using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using Unity.Jobs;

namespace Enderlook.Unity.Pathfinding.Algorithms
{
    internal static partial class PathCalculator
    {
<#
    foreach (Variation variation in new Variation[] {
        new Variation() { HasWatchdog = true , HasSearcher = true  },
        new Variation() { HasWatchdog = true , HasSearcher = false },
        new Variation() { HasWatchdog = false, HasSearcher = true  },
        new Variation() { HasWatchdog = false, HasSearcher = false },
    })
    {
        bool hasWatchdog = variation.HasWatchdog;
        bool hasSearcher = variation.HasSearcher;
        bool hasWatchdogOrSearcher = hasWatchdog || hasSearcher;

        string IfHasWatchdog(string input) => hasWatchdog ? input : "";
        string IfHasSearcher(string input) => hasSearcher ? input : "";
        string IfElseHasSearcher(string input, string otherwise) => hasSearcher ? input : otherwise;
        string IfHasntSearcher(string input) => !hasSearcher ? input : "";
        string IfHasWatchdogOrSearcher(string input) => hasWatchdogOrSearcher ? input : "";

        string genericDeclaration = "<TCoord, TNode, TNodes, TGraph, TBuilder, TPath " + IfHasSearcher(", TSearcher") + IfHasWatchdog(", TWatchdog") + ">";
        string genericConstrains =
            "where TNodes : IEnumerator<TNode>" +
            "\r\n            where TGraph : class, IGraphIntrinsic<TNode, TNodes>, IGraphHeuristic<TNode>, IGraphLocation<TNode, TCoord>" +
            "\r\n            where TBuilder : class, IPathBuilder<TNode, TCoord>, IPathFeeder<TCoord>, new()" +
            "\r\n            where TPath : class, IPathFeedable<TCoord>, IEnumerable<TCoord>" +
            IfHasSearcher("\r\n            where TSearcher : ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") +
            IfHasWatchdog("\r\n            where TWatchdog : IWatchdog");
#>
        <#= variation.ToString() #>

        public static void CalculatePathSingleThread<#= genericDeclaration #>
        (
            TGraph graph,
            TPath path,
            TCoord from
            <#= IfElseHasSearcher(", TSearcher searcher", ", TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= genericConstrains #>
        {
            ((IProcessHandleSourceCompletition)path).StartFromSync();

            var builder = ConcurrentPool<TBuilder>.Rent();

            AStar.CalculatePath
                <TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                (graph, builder, from, <#= IfElseHasSearcher("searcher", "to") #> <#= IfHasWatchdog(", watchdog") #>);

            builder.FeedPathTo(path);

            ConcurrentPool<TBuilder>.Return(builder);

            ((IProcessHandleSourceCompletition)path).EndFromSync();
        }

        private struct Handle<#= variation.Code() #><#= genericDeclaration #>
            <#= genericConstrains #>
        {
            internal TGraph graph;
            internal TPath path;
            internal TBuilder builder;
            <#= IfHasSearcher("internal TSearcher searcher;") #>
            <#= IfHasWatchdog("internal TWatchdog watchdog;") #>
            internal TCoord from;
            <#= IfHasntSearcher("internal TCoord to;") #>

            public void Set(
                TGraph graph,
                TBuilder builder,
                TPath path,
                TCoord from,
                <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
                <#= IfHasWatchdog(", TWatchdog watchdog") #>
            )
            {
                this.graph = graph;
                this.builder = builder;
                this.path = path;
                this.from = from;
                <#= IfElseHasSearcher("this.searcher = searcher;", "this.to = to;") #>
                <#= IfHasWatchdog("this.watchdog = watchdog;") #>
            }
        }

        public static void CalculatePathJobAlloc<#= genericDeclaration #>
        (
            TGraph graph,
            TPath path,
            TCoord from,
            <#= IfElseHasSearcher("TSearcher searcher", "TCoord to") #>
            <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
            <#= genericConstrains #>
        {
            var boxedHandle = ConcurrentPool<StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>>>.Rent();
            boxedHandle.Value.Set(graph, ConcurrentPool<TBuilder>.Rent(), path, from <#= IfElseHasSearcher(", searcher", ", to") #> <#= IfHasWatchdog(", watchdog") #>);

            var job = new Job<#= variation.Code() #><#= genericDeclaration #>(boxedHandle);
            JobHandle jobHandle = job.Schedule();

            ((IProcessHandleSourceCompletition)path).StartFromJobHandle(jobHandle);
        }

        private readonly struct Job<#= variation.Code() #><#= genericDeclaration #> : IJob
            <#= genericConstrains #>
        {
            private readonly GCHandle handle;

            public Job<#= variation.Code() #>(
                StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>> handle
            )
                => this.handle = GCHandle.Alloc(handle, GCHandleType.Pinned);

            public void Execute()
            {
                var boxedHandle = ((StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>>)this.handle.Target);
                var handle = boxedHandle.Value;

                AStar.CalculatePath<TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher") #> <#= IfHasWatchdog(", TWatchdog") #>>
                    (handle.graph, handle.builder, handle.from, <#= IfElseHasSearcher("handle.searcher", "handle.to") #> <#= IfHasWatchdog(", handle.watchdog") #>);

                ((IPathFeeder<TCoord>)handle.builder).FeedPathTo(handle.path);

                ((IProcessHandleSourceCompletition)handle.path).EndFromJobHandle();

                ConcurrentPool<StrongBox<Handle<#= variation.Code() #><#= genericDeclaration #>>>.Return(boxedHandle);

                this.handle.Free();
            }
        }

<#  } #>
    }
}
<#+
struct Variation
{
    public bool HasWatchdog;
    public bool HasSearcher;

    public string ToString() => String.Format("// HasWatchdog: {0} HasSearcher: {1}", HasWatchdog, HasSearcher);

    public string Code() => (HasWatchdog ? "YW" : "NW") + (HasSearcher ? "YS" : "NS");
}
#>
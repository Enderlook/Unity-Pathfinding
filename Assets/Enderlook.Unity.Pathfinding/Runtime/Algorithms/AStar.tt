<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".autogenerated.cs" #>
//====================================================================================================
// <auto-generated>       THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY       </auto-generated>
//====================================================================================================

using System.Collections.Generic;

namespace Enderlook.Unity.Pathfinding
{
    /// <summary>
    /// A pathfinder that uses the A* algorithm.<br/>
    /// Instances of this class are not thread safe.
    /// </summary>
    /// <typeparam name="TNode">Type of node.</typeparam>
    public sealed class AStar<TNode>
    {
<#
    foreach (bool hasTNodes in new bool[] { false, true })
    {
        string IfHasTNodes(string write) => hasTNodes ? write : "";

        foreach (bool hasWatchdog in new bool[] { false, true })
        {
            string IfHasWatchdog(string write) => hasWatchdog ? write : "";
#>
        /// <summary>
        /// Calculates a path from <paramref name="from"/> node to some node which satisfy <paramref name="finder"/>.<br/>
<#
        if (hasWatchdog)
        {
#>
        /// This methods accepts a <paramref name="watchDog"/> to prematurely stop the calculation.
<#
        }
#>
        /// </summary>
        /// <typeparam name="TFinder">Type of finder.</typeparam>
        /// <typeparam name="TBuilder">Type of path builder.</typeparam>
<#
        if (hasWatchdog)
        {
#>
        /// <typeparam name="TWatchdog">Type of watchdog.</typeparam>
<#
        }
#>
        /// <typeparam name="TNodes">Type of node enumeration.</typeparam>
        /// <param name="from">Node where path start.</param>
        /// <param name="finder">Fetchs the traversable graph and the cost of traversing nodes.</param>
        /// <param name="builder">Manages the building of the path by storing intermediate results.</param>
<#
        if (hasWatchdog)
        {
#>
        /// <param name="watchdog">Watchdog which determines if prematurely stop the calculation.</param>
<#
        }
#>
        public static void CalculatePath<TFinder, TBuilder <#= IfHasWatchdog(", TWatchdog") #> <#= IfHasTNodes(", TNodes") #>>(TNode from, TFinder finder, TBuilder builder <#= IfHasWatchdog(", TWatchdog watchdog") #>)
            where TFinder : IGraphIntrinsic<TNode <#= IfHasTNodes(", TNodes") #>>, IPathTargetFinderSatisfy<TNode>, IPathTargetFinderHeuristic<TNode>
            where TBuilder : IPathBuilder<TNode>
            <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
            <#= IfHasTNodes("where TNodes : IEnumerable<TNode>") #>
        {
            builder.InitializeBuilderSession(from);

            if (finder.DoesSatisfy(from))
            {
                builder.FinalizeBuilderSession(CalculationResult.PathFound, from);
                return;
            }

            builder.SetCost(from, 0);
            builder.EnqueueToVisit(from, 0);

            while (builder.TryDequeueToVisit(out TNode node))
            {
<#
            if (hasWatchdog)
            {
#>
                if (!watchdog.CanContinue())
                {
                    builder.FinalizeBuilderSession(CalculationResult.Timedout, default);
                    return;
                }
<#
            }
#>

                if (builder.WasVisited(node))
                    continue;
                builder.Visit(node);

                if (!builder.TryGetCost(node, out float costFromSource))
                    costFromSource = float.PositiveInfinity;

                foreach (TNode neighbour in finder.GetNeighbours(node))
                {
                    float cost = finder.GetCost(node, neighbour) + costFromSource;
                    if (!builder.TryGetCost(node, out float oldCost) || cost < oldCost)
                    {
                        builder.SetCost(neighbour, cost);
                        builder.SetEdge(node, neighbour);
                    }

                    builder.EnqueueToVisit(neighbour, cost + finder.GetHeuristicCost(neighbour));

                    if (finder.DoesSatisfy(neighbour))
                    {
                        builder.FinalizeBuilderSession(CalculationResult.PathFound, neighbour);
                        return;
                    }
                }
            }

            builder.FinalizeBuilderSession(CalculationResult.PathNotFound, default);
        }

<#
        }
    }
#>


        public static readonly Instance Singlenton = new Instance();

        public sealed class Instance {
<#
    foreach (bool hasTNodes in new bool[] { false, true })
    {
        string IfHasTNodes(string write) => hasTNodes ? write : "";

        foreach (bool hasWatchdog in new bool[] { false, true })
        {
            string IfHasWatchdog(string write) => hasWatchdog ? write : "";
#>
            /// <inheritdoc cref="AStar{TNode}.CalculatePath{TFinder, TBuilder <#= IfHasWatchdog(", TWatchdog") #> <#= IfHasTNodes(", TNodes") #>}(TNode, TFinder, TBuilder <#= IfHasWatchdog(", TWatchdog") #>)"/>
            public void CalculatePath<TFinder, TBuilder <#= IfHasWatchdog(", TWatchdog") #> <#= IfHasTNodes(", TNodes") #>>(TNode from, TFinder finder, TBuilder builder <#= IfHasWatchdog(", TWatchdog watchdog") #>)
                where TFinder : IGraphIntrinsic<TNode <#= IfHasTNodes(", TNodes") #>>, IPathTargetFinderSatisfy<TNode>, IPathTargetFinderHeuristic<TNode>
                where TBuilder : IPathBuilder<TNode>
                <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
                <#= IfHasTNodes("where TNodes : IEnumerable<TNode>") #>
                => AStar<TNode>.CalculatePath<TFinder, TBuilder <#= IfHasWatchdog(", TWatchdog") #> <#= IfHasTNodes(", TNodes") #>>(from, finder, builder <#= IfHasWatchdog(", watchdog") #>);

<#
        }
    }
#>
        }
    }
}
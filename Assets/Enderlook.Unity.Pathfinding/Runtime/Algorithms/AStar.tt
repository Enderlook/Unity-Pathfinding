<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".autogenerated.cs" #>
//====================================================================================================
// <auto-generated>       THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY       </auto-generated>
//====================================================================================================

using System.Collections.Generic;

namespace Enderlook.Unity.Pathfinding.Algorithms
{
    /// <summary>
    /// A pathfinder that uses the A* algorithm.
    /// </summary>
    internal static class AStar
    {
<#
    foreach (Variation variation in new Variation[] {
        new Variation() { HasWatchdog = true , HasSearcher = true  },
        new Variation() { HasWatchdog = true , HasSearcher = false },
        new Variation() { HasWatchdog = false, HasSearcher = true  },
        new Variation() { HasWatchdog = false, HasSearcher = false },
    })
    {
        bool hasWatchdog = variation.HasWatchdog;
        bool hasSearcher = variation.HasSearcher;

        string IfHasWatchdog(string input) => hasWatchdog ? input : "";
        string IfHasSearcher(string input) => hasSearcher ? input : "";
        string IfElseHasSearcher(string input, string otherwise) => hasSearcher ? input : otherwise;
        string IfHasntSearcher(string input) => !hasSearcher ? input : "";
#>
        <#= variation.ToString() #>

        public static void CalculatePath<TCoord, TNode, TNodes, TGraph, TBuilder <#= IfHasSearcher(", TSearcher ") #> <#= IfHasWatchdog(", TWatchdog") #>>(
             TGraph graph,
             TBuilder builder,
             TCoord from
             <#= IfHasntSearcher(", TCoord to") #>
             <#= IfHasSearcher(", TSearcher searcher") #>
             <#= IfHasWatchdog(", TWatchdog watchdog") #>
        )
             where TNodes : IEnumerator<TNode>
             where TGraph : class, IGraphIntrinsic<TNode, TNodes> <#= IfHasntSearcher(", IGraphHeuristic<TNode>") #>, IGraphLocation<TNode, TCoord>, IGraphLineOfSight<TCoord>
             where TBuilder : IPathBuilder<TNode, TCoord>
             <#= IfHasSearcher("where TSearcher :  ISearcherSatisfy<TNode>, ISearcherHeuristic<TNode>") #>
             <#= IfHasWatchdog("where TWatchdog : IWatchdog") #>
        {
            builder.InitializeBuilderSession();
            builder.SetGraphLocation(graph);
            builder.SetLineOfSight(graph);
            TNode from_ = graph.FindClosestNodeTo(from);
            builder.SetStart(from, from_);

<#      if (hasSearcher) { #>
            if (searcher.DoesSatisfy(from_))
<#      } else { #>
            TNode to_ = graph.FindClosestNodeTo(to);
            if (EqualityComparer<TNode>.Default.Equals(from_, to_))
<#      } #>
            {
                builder.SetEnd(from, from_);
                builder.FinalizeBuilderSession(CalculationResult.PathFound);
                return;
            }

            builder.SetCost(from_, 0);
            builder.EnqueueToVisit(from_, 0);

            while (builder.TryDequeueToVisit(out TNode node))
            {
<#      if (hasWatchdog) { #>
                if (!watchdog.CanContinue())
                {
                    builder.SetEnd(default, default);
                    builder.FinalizeBuilderSession(CalculationResult.Timedout);
                    return;
                }
<#      } #>

                if (builder.WasVisited(node))
                    continue;
                builder.Visit(node);

                if (!builder.TryGetCost(node, out float costFromSource))
                    costFromSource = float.PositiveInfinity;

                TNodes neighbours = graph.GetNeighbours(node);
                try
                {
                    TNode neighbour;
                    while (neighbours.MoveNext())
                    {
                        neighbour = neighbours.Current;

                        float cost = graph.GetCost(node, neighbour) + costFromSource;
                        if (!builder.TryGetCost(neighbour, out float oldCost) || cost < oldCost)
                        {
                            builder.SetCost(neighbour, cost);
                            builder.SetEdge(node, neighbour);
                        }

                        float costWithHeuristic = cost + <#= IfElseHasSearcher("searcher.GetHeuristicCost(neighbour)", "graph.GetHeuristicCost(neighbour, to_)") #>;
                        builder.EnqueueToVisit(neighbour, costWithHeuristic);

<#      if (hasSearcher) { #>
                        if (searcher.DoesSatisfy(neighbour))
<#      } else { #>
                        if (EqualityComparer<TNode>.Default.Equals(to_, neighbour))
<#      } #>
                        {
                            builder.SetEnd(<#= IfElseHasSearcher("graph.ToPosition(neighbour)", "to") #>, neighbour);
                            builder.FinalizeBuilderSession(CalculationResult.PathFound);
                            return;
                        }
                    }
                }
                finally
                {
                   neighbours.Dispose();
                }
            }

            builder.SetEnd(default, default);
            builder.FinalizeBuilderSession(CalculationResult.PathNotFound);
        }

<#  } #>
    }
}
<#+
struct Variation
{
    public bool HasWatchdog;
    public bool HasSearcher;

    public string ToString() => String.Format("// HasWatchdog: {0} HasSearcher: {1}", HasWatchdog, HasSearcher);
}
#>